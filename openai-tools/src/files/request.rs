//! OpenAI Files API Request Module
//!
//! This module provides the functionality to interact with the OpenAI Files API.
//! It allows you to upload, list, retrieve, delete files, and get file content.
//!
//! # Key Features
//!
//! - **Upload Files**: Upload files for fine-tuning, batch processing, assistants, etc.
//! - **List Files**: Retrieve all uploaded files
//! - **Retrieve File**: Get details of a specific file
//! - **Delete File**: Remove an uploaded file
//! - **Get Content**: Retrieve the content of a file
//!
//! # Quick Start
//!
//! ```rust,no_run
//! use openai_tools::files::request::{Files, FilePurpose};
//!
//! #[tokio::main]
//! async fn main() -> Result<(), Box<dyn std::error::Error>> {
//!     let files = Files::new()?;
//!
//!     // List all files
//!     let response = files.list(None).await?;
//!     for file in &response.data {
//!         println!("{}: {} bytes", file.filename, file.bytes);
//!     }
//!
//!     Ok(())
//! }
//! ```

use crate::common::errors::{ErrorResponse, OpenAIToolError, Result};
use crate::files::response::{DeleteResponse, File, FileListResponse};
use dotenvy::dotenv;
use request::multipart::{Form, Part};
use serde::{Deserialize, Serialize};
use std::env;
use std::path::Path;

const BASE_URL: &str = "https://api.openai.com/v1/files";

/// The intended purpose of the uploaded file.
///
/// Different purposes have different processing requirements and usage patterns.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum FilePurpose {
    /// For use with Assistants and Message files
    Assistants,
    /// For files generated by Assistants
    AssistantsOutput,
    /// For use with Batch API
    Batch,
    /// For files generated by Batch API
    BatchOutput,
    /// For use with Fine-tuning
    FineTune,
    /// For files generated by Fine-tuning
    FineTuneResults,
    /// For use with Vision features
    Vision,
    /// For user-uploaded data
    UserData,
}

impl FilePurpose {
    /// Returns the string representation of the purpose.
    pub fn as_str(&self) -> &'static str {
        match self {
            FilePurpose::Assistants => "assistants",
            FilePurpose::AssistantsOutput => "assistants_output",
            FilePurpose::Batch => "batch",
            FilePurpose::BatchOutput => "batch_output",
            FilePurpose::FineTune => "fine-tune",
            FilePurpose::FineTuneResults => "fine-tune-results",
            FilePurpose::Vision => "vision",
            FilePurpose::UserData => "user_data",
        }
    }
}

impl std::fmt::Display for FilePurpose {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

/// Client for interacting with the OpenAI Files API.
///
/// This struct provides methods to upload, list, retrieve, delete files,
/// and get file content. Use [`Files::new()`] to create a new instance.
///
/// # Example
///
/// ```rust,no_run
/// use openai_tools::files::request::{Files, FilePurpose};
///
/// #[tokio::main]
/// async fn main() -> Result<(), Box<dyn std::error::Error>> {
///     let files = Files::new()?;
///
///     // Upload a file for fine-tuning
///     let file = files.upload_path("training_data.jsonl", FilePurpose::FineTune).await?;
///     println!("Uploaded: {} ({})", file.filename, file.id);
///
///     Ok(())
/// }
/// ```
pub struct Files {
    /// OpenAI API key for authentication
    api_key: String,
}

impl Files {
    /// Creates a new Files client.
    ///
    /// Initializes the client by loading the OpenAI API key from
    /// the environment variable `OPENAI_API_KEY`. Supports `.env` file loading
    /// via dotenvy.
    ///
    /// # Returns
    ///
    /// * `Ok(Files)` - A new Files client ready for use
    /// * `Err(OpenAIToolError)` - If the API key is not found in the environment
    ///
    /// # Example
    ///
    /// ```rust,no_run
    /// use openai_tools::files::request::Files;
    ///
    /// let files = Files::new().expect("API key should be set");
    /// ```
    pub fn new() -> Result<Self> {
        dotenv().ok();
        let api_key = env::var("OPENAI_API_KEY").map_err(|e| {
            OpenAIToolError::Error(format!("OPENAI_API_KEY not set in environment: {}", e))
        })?;
        Ok(Self { api_key })
    }

    /// Creates the HTTP client with default headers.
    fn create_client(&self) -> (request::Client, request::header::HeaderMap) {
        let client = request::Client::new();
        let mut headers = request::header::HeaderMap::new();
        headers.insert(
            "Authorization",
            request::header::HeaderValue::from_str(&format!("Bearer {}", self.api_key)).unwrap(),
        );
        headers.insert(
            "User-Agent",
            request::header::HeaderValue::from_static("openai-tools-rust"),
        );
        (client, headers)
    }

    /// Uploads a file from a file path.
    ///
    /// The file will be uploaded with the specified purpose.
    /// Individual files can be up to 512 MB, and the total size of all files
    /// uploaded by one organization can be up to 100 GB.
    ///
    /// # Arguments
    ///
    /// * `file_path` - Path to the file to upload
    /// * `purpose` - The intended purpose of the uploaded file
    ///
    /// # Returns
    ///
    /// * `Ok(File)` - The uploaded file object
    /// * `Err(OpenAIToolError)` - If the file cannot be read or the upload fails
    ///
    /// # Example
    ///
    /// ```rust,no_run
    /// use openai_tools::files::request::{Files, FilePurpose};
    ///
    /// #[tokio::main]
    /// async fn main() -> Result<(), Box<dyn std::error::Error>> {
    ///     let files = Files::new()?;
    ///     let file = files.upload_path("data.jsonl", FilePurpose::FineTune).await?;
    ///     println!("Uploaded: {}", file.id);
    ///     Ok(())
    /// }
    /// ```
    pub async fn upload_path(&self, file_path: &str, purpose: FilePurpose) -> Result<File> {
        let path = Path::new(file_path);
        let filename = path
            .file_name()
            .and_then(|n| n.to_str())
            .unwrap_or("file")
            .to_string();

        let content = tokio::fs::read(file_path)
            .await
            .map_err(|e| OpenAIToolError::Error(format!("Failed to read file: {}", e)))?;

        self.upload_bytes(&content, &filename, purpose).await
    }

    /// Uploads a file from bytes.
    ///
    /// The file will be uploaded with the specified filename and purpose.
    ///
    /// # Arguments
    ///
    /// * `content` - The file content as bytes
    /// * `filename` - The name to give the file
    /// * `purpose` - The intended purpose of the uploaded file
    ///
    /// # Returns
    ///
    /// * `Ok(File)` - The uploaded file object
    /// * `Err(OpenAIToolError)` - If the upload fails
    ///
    /// # Example
    ///
    /// ```rust,no_run
    /// use openai_tools::files::request::{Files, FilePurpose};
    ///
    /// #[tokio::main]
    /// async fn main() -> Result<(), Box<dyn std::error::Error>> {
    ///     let files = Files::new()?;
    ///
    ///     let content = b"{\"messages\": [{\"role\": \"user\", \"content\": \"Hello\"}]}";
    ///     let file = files.upload_bytes(content, "training.jsonl", FilePurpose::FineTune).await?;
    ///
    ///     println!("Uploaded: {}", file.id);
    ///     Ok(())
    /// }
    /// ```
    pub async fn upload_bytes(
        &self,
        content: &[u8],
        filename: &str,
        purpose: FilePurpose,
    ) -> Result<File> {
        let (client, headers) = self.create_client();

        let file_part = Part::bytes(content.to_vec())
            .file_name(filename.to_string())
            .mime_str("application/octet-stream")
            .map_err(|e| OpenAIToolError::Error(format!("Failed to set MIME type: {}", e)))?;

        let form = Form::new()
            .part("file", file_part)
            .text("purpose", purpose.as_str().to_string());

        let response = client
            .post(BASE_URL)
            .headers(headers)
            .multipart(form)
            .send()
            .await
            .map_err(OpenAIToolError::RequestError)?;

        let status = response.status();
        let content = response.text().await.map_err(OpenAIToolError::RequestError)?;

        if cfg!(test) {
            tracing::info!("Response content: {}", content);
        }

        if !status.is_success() {
            if let Ok(error_resp) = serde_json::from_str::<ErrorResponse>(&content) {
                return Err(OpenAIToolError::Error(error_resp.error.message.unwrap_or_default()));
            }
            return Err(OpenAIToolError::Error(format!("API error ({}): {}", status, content)));
        }

        serde_json::from_str::<File>(&content).map_err(OpenAIToolError::SerdeJsonError)
    }

    /// Lists all files that belong to the user's organization.
    ///
    /// Optionally filter by purpose.
    ///
    /// # Arguments
    ///
    /// * `purpose` - Optional filter by file purpose
    ///
    /// # Returns
    ///
    /// * `Ok(FileListResponse)` - The list of files
    /// * `Err(OpenAIToolError)` - If the request fails
    ///
    /// # Example
    ///
    /// ```rust,no_run
    /// use openai_tools::files::request::{Files, FilePurpose};
    ///
    /// #[tokio::main]
    /// async fn main() -> Result<(), Box<dyn std::error::Error>> {
    ///     let files = Files::new()?;
    ///
    ///     // List all files
    ///     let all_files = files.list(None).await?;
    ///     println!("Total files: {}", all_files.data.len());
    ///
    ///     // List only fine-tuning files
    ///     let ft_files = files.list(Some(FilePurpose::FineTune)).await?;
    ///     println!("Fine-tuning files: {}", ft_files.data.len());
    ///
    ///     Ok(())
    /// }
    /// ```
    pub async fn list(&self, purpose: Option<FilePurpose>) -> Result<FileListResponse> {
        let (client, headers) = self.create_client();

        let url = match purpose {
            Some(p) => format!("{}?purpose={}", BASE_URL, p.as_str()),
            None => BASE_URL.to_string(),
        };

        let response = client
            .get(&url)
            .headers(headers)
            .send()
            .await
            .map_err(OpenAIToolError::RequestError)?;

        let status = response.status();
        let content = response.text().await.map_err(OpenAIToolError::RequestError)?;

        if cfg!(test) {
            tracing::info!("Response content: {}", content);
        }

        if !status.is_success() {
            if let Ok(error_resp) = serde_json::from_str::<ErrorResponse>(&content) {
                return Err(OpenAIToolError::Error(error_resp.error.message.unwrap_or_default()));
            }
            return Err(OpenAIToolError::Error(format!("API error ({}): {}", status, content)));
        }

        serde_json::from_str::<FileListResponse>(&content).map_err(OpenAIToolError::SerdeJsonError)
    }

    /// Retrieves details of a specific file.
    ///
    /// # Arguments
    ///
    /// * `file_id` - The ID of the file to retrieve
    ///
    /// # Returns
    ///
    /// * `Ok(File)` - The file details
    /// * `Err(OpenAIToolError)` - If the file is not found or the request fails
    ///
    /// # Example
    ///
    /// ```rust,no_run
    /// use openai_tools::files::request::Files;
    ///
    /// #[tokio::main]
    /// async fn main() -> Result<(), Box<dyn std::error::Error>> {
    ///     let files = Files::new()?;
    ///     let file = files.retrieve("file-abc123").await?;
    ///
    ///     println!("File: {}", file.filename);
    ///     println!("Size: {} bytes", file.bytes);
    ///     println!("Purpose: {}", file.purpose);
    ///     Ok(())
    /// }
    /// ```
    pub async fn retrieve(&self, file_id: &str) -> Result<File> {
        let (client, headers) = self.create_client();
        let url = format!("{}/{}", BASE_URL, file_id);

        let response = client
            .get(&url)
            .headers(headers)
            .send()
            .await
            .map_err(OpenAIToolError::RequestError)?;

        let status = response.status();
        let content = response.text().await.map_err(OpenAIToolError::RequestError)?;

        if cfg!(test) {
            tracing::info!("Response content: {}", content);
        }

        if !status.is_success() {
            if let Ok(error_resp) = serde_json::from_str::<ErrorResponse>(&content) {
                return Err(OpenAIToolError::Error(error_resp.error.message.unwrap_or_default()));
            }
            return Err(OpenAIToolError::Error(format!("API error ({}): {}", status, content)));
        }

        serde_json::from_str::<File>(&content).map_err(OpenAIToolError::SerdeJsonError)
    }

    /// Deletes a file.
    ///
    /// # Arguments
    ///
    /// * `file_id` - The ID of the file to delete
    ///
    /// # Returns
    ///
    /// * `Ok(DeleteResponse)` - Confirmation of deletion
    /// * `Err(OpenAIToolError)` - If the file cannot be deleted or the request fails
    ///
    /// # Example
    ///
    /// ```rust,no_run
    /// use openai_tools::files::request::Files;
    ///
    /// #[tokio::main]
    /// async fn main() -> Result<(), Box<dyn std::error::Error>> {
    ///     let files = Files::new()?;
    ///     let result = files.delete("file-abc123").await?;
    ///
    ///     if result.deleted {
    ///         println!("File {} was deleted", result.id);
    ///     }
    ///     Ok(())
    /// }
    /// ```
    pub async fn delete(&self, file_id: &str) -> Result<DeleteResponse> {
        let (client, headers) = self.create_client();
        let url = format!("{}/{}", BASE_URL, file_id);

        let response = client
            .delete(&url)
            .headers(headers)
            .send()
            .await
            .map_err(OpenAIToolError::RequestError)?;

        let status = response.status();
        let content = response.text().await.map_err(OpenAIToolError::RequestError)?;

        if cfg!(test) {
            tracing::info!("Response content: {}", content);
        }

        if !status.is_success() {
            if let Ok(error_resp) = serde_json::from_str::<ErrorResponse>(&content) {
                return Err(OpenAIToolError::Error(error_resp.error.message.unwrap_or_default()));
            }
            return Err(OpenAIToolError::Error(format!("API error ({}): {}", status, content)));
        }

        serde_json::from_str::<DeleteResponse>(&content).map_err(OpenAIToolError::SerdeJsonError)
    }

    /// Retrieves the content of a file.
    ///
    /// # Arguments
    ///
    /// * `file_id` - The ID of the file to retrieve content from
    ///
    /// # Returns
    ///
    /// * `Ok(Vec<u8>)` - The file content as bytes
    /// * `Err(OpenAIToolError)` - If the file cannot be retrieved or the request fails
    ///
    /// # Example
    ///
    /// ```rust,no_run
    /// use openai_tools::files::request::Files;
    ///
    /// #[tokio::main]
    /// async fn main() -> Result<(), Box<dyn std::error::Error>> {
    ///     let files = Files::new()?;
    ///     let content = files.content("file-abc123").await?;
    ///
    ///     // Convert to string if it's text content
    ///     let text = String::from_utf8(content)?;
    ///     println!("Content: {}", text);
    ///     Ok(())
    /// }
    /// ```
    pub async fn content(&self, file_id: &str) -> Result<Vec<u8>> {
        let (client, headers) = self.create_client();
        let url = format!("{}/{}/content", BASE_URL, file_id);

        let response = client
            .get(&url)
            .headers(headers)
            .send()
            .await
            .map_err(OpenAIToolError::RequestError)?;

        let bytes = response
            .bytes()
            .await
            .map_err(OpenAIToolError::RequestError)?;

        Ok(bytes.to_vec())
    }
}
